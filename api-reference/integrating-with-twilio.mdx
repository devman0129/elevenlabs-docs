---
title: "How to send an AI message through a phone call using Twilio and ElevenLabs in Node.js and Python"
sidebarTitle: "Integrating with Twilio"
description: ""
icon: "phone"
---

In this guide, you’ll learn how to send an AI generated message through a phone call using Twilio and ElevenLabs. This process allows you to send high-quality voice messages directly to your callers.

## Create accounts with Twilio and ngrok

We’ll be using Twilio and ngrok for this guide, so go ahead and create accounts with them.

- [twilio.com](https://www.twilio.com)
- [ngrok.com](https://ngrok.com)

## Get the code

If you want to get started quickly, you can get the entire code for this guide on [GitHub](https://github.com/elevenlabs/elevenlabs-examples/tree/main/examples/twilio/call)

## Create the server (Express for Node.js or Flask for Python)

### Initialize your project

Create a new folder for your project

<CodeGroup>
```bash TypeScript
# Initialize your project
mkdir elevenlabs-twilio
cd elevenlabs-twilio
npm init -y

# Install dependencies

npm install elevenlabs express express-ws twilio

# Install dev dependencies

npm i @types/node @types/express @types/express-ws @types/ws dotenv tsx typescript

````

```bash Python
mkdir elevenlabs-twilio
cd elevenlabs-twilio
pip install flask flask-socketio python-dotenv twilio elevenlabs
````

</CodeGroup>

### Create your files

<CodeGroup>
```typescript src/app.ts (TypeScript)
import "dotenv/config";
import express, { Response } from "express";
import ExpressWs from "express-ws";
import VoiceResponse from "twilio/lib/twiml/VoiceResponse";
import { ElevenLabsClient } from "elevenlabs";
import { type WebSocket } from "ws";
import { type Readable } from "stream";

const app = ExpressWs(express()).app;
const PORT: number = parseInt(process.env.PORT || '5000');

const elevenlabs = new ElevenLabsClient();
const voiceId = '21m00Tcm4TlvDq8ikWAM';
const outputFormat = 'ulaw_8000';
const text = 'This is a test. You can now hang up. Thank you.';

function startApp() {
  app.post('/call/incoming', (_, res: Response) => {
    const twiml = new VoiceResponse();

    twiml.connect().stream({
      url: `wss://${process.env.SERVER_DOMAIN}/call/connection`,
    });

    res.writeHead(200, { 'Content-Type': 'text/xml' });
    res.end(twiml.toString());
  });

  app.ws('/call/connection', (ws: WebSocket) => {
    ws.on('message', async (data: string) => {
      const message: {
        event: string;
        start?: { streamSid: string; callSid: string };
      } = JSON.parse(data);

      if (message.event === 'start' && message.start) {
        const streamSid = message.start.streamSid;
        const response = await elevenlabs.textToSpeech.convert(voiceId, {
          model_id: 'eleven_turbo_v2',
          output_format: outputFormat,
          text,
        });

        const audioArrayBuffer = await streamToArrayBuffer(response);

        ws.send(
          JSON.stringify({
            streamSid,
            event: 'media',
            media: {
              payload: Buffer.from(audioArrayBuffer as any).toString('base64'),
            },
          }),
        );
      }
    });

    ws.on('error', console.error);
  });

  app.listen(PORT, () => {
    console.log(`Local: http://localhost:${PORT}`);
    console.log(`Remote: https://${process.env.SERVER_DOMAIN}`);
  });
}

function streamToArrayBuffer(readableStream: Readable) {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];

    readableStream.on('data', (chunk) => {
      chunks.push(chunk);
    });

    readableStream.on('end', () => {
      resolve(Buffer.concat(chunks).buffer);
    });

    readableStream.on('error', reject);
  });
}

startApp();

````

```python main.py (Python)
import os
import json
from io import BytesIO
from flask import Flask, make_response
from flask_socketio import SocketIO, emit
from elevenlabs.client import ElevenLabs
from twilio.twiml.voice_response import VoiceResponse

from dotenv import load_dotenv

load_dotenv()

ELEVENLABS_API_KEY = os.getenv("ELEVENLABS_API_KEY")
SERVER_DOMAIN = os.getenv("SERVER_DOMAIN")

if not ELEVENLABS_API_KEY:
    raise ValueError("ELEVENLABS_API_KEY environment variable not set")

if not SERVER_DOMAIN:
    raise ValueError("SERVER_DOMAIN environment variable not set")

client = ElevenLabs(
    api_key=ELEVENLABS_API_KEY,
)

app = Flask(__name__)
socketio = SocketIO(app)
PORT = int(os.getenv("PORT", 5000))

voice_id = "21m00Tcm4TlvDq8ikWAM"
output_format = "ulaw_8000"
text = "This is a test. You can now hang up. Thank you."


@app.route("/call/incoming", methods=["POST"])
def handle_incoming_call():
    twiml = VoiceResponse()
    twiml.connect().stream(url=f"wss://{SERVER_DOMAIN}/call/connection")

    response = make_response(twiml.to_xml())
    response.headers["Content-Type"] = "text/xml"
    return response


@socketio.on("message", namespace="/call/connection")
def handle_message(data):
    message = json.loads(data)
    if message["event"] == "start" and "start" in message:
        stream_sid = message["start"]["streamSid"]

        response = client.text_to_speech.convert(
            voice_id=voice_id,
            output_format=output_format,
            model_id="eleven_turbo_v2",
            text=text,
        )

        audio_array_buffer = stream_to_array_buffer(response)

        emit(
            "media",
            {
                "streamSid": stream_sid,
                "event": "media",
                "media": {"payload": audio_array_buffer},
            },
        )


def stream_to_array_buffer(readable_stream):
    audio_stream = BytesIO()
    for chunk in readable_stream:
        if chunk:
            audio_stream.write(chunk)
    audio_stream.seek(0)

    return audio_stream


if __name__ == "__main__":
    socketio.run(app, host="0.0.0.0", port=PORT)
````

</CodeGroup>

```bash .env
SERVER_DOMAIN=
ELEVENLABS_API_KEY=
```

### Understanding the Typescript code

<AccordionGroup>

<Accordion title="Handle the incoming call">
When you call your number, Twilio makes a POST request to your endpoint at `/call/incoming`.
We then use twiml.connect to tell Twilio that we want to handle the call via our websocket by setting the url to our `/call/connection` endpoint.

```ts
function startApp() {
  app.post('/call/incoming', (_, res: Response) => {
    const twiml = new VoiceResponse();

    twiml.connect().stream({
      url: `wss://${process.env.SERVER_DOMAIN}/call/connection`,
    });

    res.writeHead(200, { 'Content-Type': 'text/xml' });
    res.end(twiml.toString());
  });
```

</Accordion>

<Accordion title="Creating the text to speech">

Here we listen for messages that Twilio sends to our websocket endpoint. When we receive a `start` message event, we generate audio using the ElevenLabs [TypeScript SDK](https://github.com/elevenlabs/elevenlabs-js).

```ts
  app.ws('/call/connection', (ws: WebSocket) => {
    ws.on('message', async (data: string) => {
      const message: {
        event: string;
        start?: { streamSid: string; callSid: string };
      } = JSON.parse(data);

      if (message.event === 'start' && message.start) {
        const streamSid = message.start.streamSid;
        const response = await elevenlabs.textToSpeech.convert(voiceId, {
          model_id: 'eleven_turbo_v2',
          output_format: outputFormat,
          text,
        });
```

</Accordion>

<Accordion title="Sending the message"  >

Upon receiving the audio back from ElevenLabs, we convert it to an array buffer and send the audio to Twilio via the websocket.

```ts
const audioArrayBuffer = await streamToArrayBuffer(response);

ws.send(
  JSON.stringify({
    streamSid,
    event: "media",
    media: {
      payload: Buffer.from(audioArrayBuffer as any).toString("base64"),
    },
  })
);
```

</Accordion>

</AccordionGroup>

### Understanding the Python code

<AccordionGroup>

<Accordion title="Setting Up The Environment">

At the beginning of the script, environment variables are loaded using `load_dotenv()` from `dotenv`, which populates the `os.environ` dictionary with values from a `.env` file located in the same directory as the script. The script fetches necessary API keys and settings like the `ELEVENLABS_API_KEY` and the `SERVER_DOMAIN`.

```python
load_dotenv()

ELEVENLABS_API_KEY = os.getenv("ELEVENLABS_API_KEY")
SERVER_DOMAIN = os.getenv("SERVER_DOMAIN")

if not ELEVENLABS_API_KEY:
    raise ValueError("ELEVENLABS_API_KEY environment variable not set")

if not SERVER_DOMAIN:
    raise ValueError("SERVER_DOMAIN environment variable not set")
```

</Accordion>

<Accordion title="Creating the Flask and SocketIO Server">

An instance of a Flask application is created, and the `SocketIO` plugin is initialized with it. This setup will allow the application to handle HTTP requests and WebSocket events. Furthermore, a default port is set up which can also be overridden by an environment variable.

```python
app = Flask(__name__)
socketio = SocketIO(app)
PORT = int(os.getenv("PORT", 5000))
```

</Accordion>

<Accordion title="Handling Incoming Calls">

The application defines a route for `/call/incoming` that Twilio uses to notify the app of incoming calls. The logic within this route generates TwiML (Twilio Markup Language) instructions to connect the call to a WebSocket stream. The URL of that WebSocket stream is constructed using the `SERVER_DOMAIN`.

```python
@app.route("/call/incoming", methods=["POST"])
def handle_incoming_call():
    twiml = VoiceResponse()
    twiml.connect().stream(url=f"wss://{SERVER_DOMAIN}/call/connection")

    response = make_response(twiml.to_xml())
    response.headers["Content-Type"] = "text/xml"
    return response
```

</Accordion>

<Accordion title="Text to Speech Conversion and WebSockets">
The server listens for messages on the `/call/connection` WebSocket namespace. When it receives a message event of type `start`, it triggers audio generation using ElevenLabs's `text_to_speech.convert` method. Then, it converts the audio to an array buffer using a helper function `stream_to_array_buffer` and emits the audio data to the WebSocket stream, so it can be played during the phone call.

```python
@socketio.on("message", namespace="/call/connection")
def handle_message(data):
    message = json.loads(data)
    if message["event"] == "start" and "start" in message:
        stream_sid = message["start"]["streamSid"]
        response = client.text_to_speech.convert(
            voice_id=voice_id,
            output_format=output_format,
            model_id="eleven_turbo_v2",
            text=text,
        )
        audio_array_buffer = stream_to_array_buffer(response)
        emit(
            "media",
            {
                "streamSid": stream_sid,
                "event": "media",
                "media": {"payload": audio_array_buffer},
            },
        )
```

</Accordion>

<Accordion title="Converting the Audio Stream to an Array Buffer">
The `stream_to_array_buffer` function takes a stream of data (presumably the audio data generated by ElevenLabs's service), reads it in chunks into a `BytesIO` object, and returns a seeked-to-start buffer that can be transmitted over the WebSocket.

```python
def stream_to_array_buffer(readable_stream):
    audio_stream = BytesIO()
    for chunk in readable_stream:
        if chunk:
            audio_stream.write(chunk)
    audio_stream.seek(0)
    return audio_stream
```

</Accordion>

<Accordion title="Running the Application">
Finally, the script contains the execution guard to ensure this script runs as the main program. This is where the Flask app, along with its Socket.IO server, gets executed on the specified host and port.

```python
if __name__ == "__main__":
    socketio.run(app, host="0.0.0.0", port=PORT)
```

</Accordion>

</AccordionGroup>

## Point ngrok to your application

Twilio requires a publicly accessible URL. We’ll use ngrok to forward the local port of our application and expose it as a public URL.

Run the following command in your terminal:

```
ngrok http 5000
```

Copy the ngrok domain (without https://) to use in your environment variables.

<img height="200" src="/api-reference/images/ngrok.png" />

## Update your environment variables

Update the `.env` file with your ngrok domain and ElevenLabs API key.

```
# .env
SERVER_DOMAIN=*******.ngrok.app
ELEVENLABS_API_KEY=*************************
```

## Start the application

Run the following command to start the app:

<CodeGroup>
```bash TypeScript
npm run dev
```

```bash Python
# Linux
python3 app.py

# Windows
py app.py
```

</CodeGroup>

## Set up Twilio

Follow Twilio’s guides to create a new number. Once you’ve created your number, navigate to the “Configure” tab in Phone Numbers -> Manage -> Active numbers

In the “A call comes in” section, enter the full URL to your application (make sure to add the`/call/incoming` path):

E.g. https://*******ngrok.app/call/incoming

<img height="200" src="/api-reference/images/twilio.png" />

## Make a phone call

Make a call to your number. You should hear a message using the ElevenLabs voice.

## Tips for deploying to production

When running the application in production, make sure to set the `SERVER_DOMAIN` environment variable to that of your server. Be sure to also update the URL in Twilio to point to your production server.

## Conclusion

You should now have a basic understanding of integrating Twilio with ElevenLabs voices. If you have any further questions, or suggestions on how to improve this blog post, please feel free to select the “Suggest edits” or “Raise issue” button below.
